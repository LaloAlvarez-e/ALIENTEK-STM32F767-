
Project.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .intvecs      00000208  08000000  08000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000006d4  08000400  08000400  00010400  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .init         0000000c  08000ad4  08000ad4  00010ad4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .finit        00000010  08000ae0  08000ae0  00010ae0  2**2
                  CONTENTS, ALLOC, LOAD, CODE
  4 .ARM.extab    00000000  08000af0  08000af0  0001c118  2**0
                  CONTENTS
  5 .ARM.exidx    00000000  08000af0  08000af0  0001c118  2**0
                  CONTENTS
  6 .preinit_array 00000000  08000af0  08000af0  0001c118  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  7 .init_array   00000004  08000af0  08000af0  00010af0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .fini_array   00000000  08000af4  08000af4  0001c118  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .itcmramcode  00000000  00000400  00000400  0001c118  2**0
                  CONTENTS
 10 .ramcode      00000118  2007c000  08000af4  0001c000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 11 .rodata       00000000  08000af4  08000af4  0001c118  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 12 .data         00000000  20020000  20020000  0001c118  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 13 .bss          0000001c  20020000  08000af4  00020000  2**2
                  ALLOC
 14 .heap         00000000  20060000  20060000  0001c118  2**0
                  CONTENTS
 15 .ARM.attributes 0000002e  00000000  00000000  0001c118  2**0
                  CONTENTS, READONLY
 16 .debug_info   00004732  00000000  00000000  0001c146  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_abbrev 000016c8  00000000  00000000  00020878  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_aranges 000003d0  00000000  00000000  00021f40  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_ranges 00000260  00000000  00000000  00022310  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  000154dd  00000000  00000000  00022570  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line   0000e983  00000000  00000000  00037a4d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_str    000af3ab  00000000  00000000  000463d0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .comment      00000050  00000000  00000000  000f577b  2**0
                  CONTENTS, READONLY
 24 .debug_frame  000006b0  00000000  00000000  000f57cc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 25 .debug_loc    000021d0  00000000  00000000  000f5e7c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000400 <__do_global_dtors_aux>:
 8000400:	b510      	push	{r4, lr}
 8000402:	4c05      	ldr	r4, [pc, #20]	; (8000418 <__do_global_dtors_aux+0x18>)
 8000404:	7823      	ldrb	r3, [r4, #0]
 8000406:	b933      	cbnz	r3, 8000416 <__do_global_dtors_aux+0x16>
 8000408:	4b04      	ldr	r3, [pc, #16]	; (800041c <__do_global_dtors_aux+0x1c>)
 800040a:	b113      	cbz	r3, 8000412 <__do_global_dtors_aux+0x12>
 800040c:	4804      	ldr	r0, [pc, #16]	; (8000420 <__do_global_dtors_aux+0x20>)
 800040e:	f3af 8000 	nop.w
 8000412:	2301      	movs	r3, #1
 8000414:	7023      	strb	r3, [r4, #0]
 8000416:	bd10      	pop	{r4, pc}
 8000418:	20020000 	.word	0x20020000
 800041c:	00000000 	.word	0x00000000
 8000420:	08000ad4 	.word	0x08000ad4

08000424 <frame_dummy>:
 8000424:	b508      	push	{r3, lr}
 8000426:	4b03      	ldr	r3, [pc, #12]	; (8000434 <frame_dummy+0x10>)
 8000428:	b11b      	cbz	r3, 8000432 <frame_dummy+0xe>
 800042a:	4903      	ldr	r1, [pc, #12]	; (8000438 <frame_dummy+0x14>)
 800042c:	4803      	ldr	r0, [pc, #12]	; (800043c <frame_dummy+0x18>)
 800042e:	f3af 8000 	nop.w
 8000432:	bd08      	pop	{r3, pc}
 8000434:	00000000 	.word	0x00000000
 8000438:	20020004 	.word	0x20020004
 800043c:	08000ad4 	.word	0x08000ad4

08000440 <MCU__vSetFPUContextActive>:
 	.align 	4
	.global MCU__vSetFPUContextActive
 	.type MCU__vSetFPUContextActive, %function
    .thumb_func
MCU__vSetFPUContextActive:
	push    {r1,r2}
 8000440:	b406      	push	{r1, r2}
	mrs     r1, CONTROL
 8000442:	f3ef 8114 	mrs	r1, CONTROL
	ubfx    r2, r1, #2, #1
 8000446:	f3c1 0280 	ubfx	r2, r1, #2, #1
	bfi     r1, r0, #2, #1
 800044a:	f360 0182 	bfi	r1, r0, #2, #1
	msr     CONTROL, r1
 800044e:	f381 8814 	msr	CONTROL, r1
	dsb
 8000452:	f3bf 8f4f 	dsb	sy
	isb
 8000456:	f3bf 8f6f 	isb	sy
	pop     {r1,r2}
 800045a:	bc06      	pop	{r1, r2}
	bx      lr
 800045c:	4770      	bx	lr
 800045e:	bf00      	nop

08000460 <MCU__enSetFPUContextActive>:
 	.align 	4
    .thumb_func
	.global MCU__enSetFPUContextActive
 	.type MCU__enSetFPUContextActive, %function
MCU__enSetFPUContextActive:
	push    {r1,r2}
 8000460:	b406      	push	{r1, r2}
	mrs     r1, CONTROL
 8000462:	f3ef 8114 	mrs	r1, CONTROL
	ubfx    r2, r1, #2, #1
 8000466:	f3c1 0280 	ubfx	r2, r1, #2, #1
	bfi     r1, r0, #2, #1
 800046a:	f360 0182 	bfi	r1, r0, #2, #1
	msr     CONTROL, r1
 800046e:	f381 8814 	msr	CONTROL, r1
	dsb
 8000472:	f3bf 8f4f 	dsb	sy
	isb
 8000476:	f3bf 8f6f 	isb	sy
	mov     r0, r2
 800047a:	4610      	mov	r0, r2
	pop     {r1,r2}
 800047c:	bc06      	pop	{r1, r2}
	bx      lr
 800047e:	4770      	bx	lr

08000480 <MCU__enGetFPUContextActive>:
 	.align 	4
    .thumb_func
	.global MCU__enGetFPUContextActive
 	.type MCU__enGetFPUContextActive, %function
MCU__enGetFPUContextActive:
	push    {r1,r2}
 8000480:	b406      	push	{r1, r2}
	mrs     r1, CONTROL
 8000482:	f3ef 8114 	mrs	r1, CONTROL
	ubfx    r0, r1, #2, #1
 8000486:	f3c1 0080 	ubfx	r0, r1, #2, #1
	pop     {r1,r2}
 800048a:	bc06      	pop	{r1, r2}
	bx      lr
 800048c:	4770      	bx	lr
 800048e:	bf00      	nop

08000490 <MCU__enSetStackActive>:
 	.align 	4
    .thumb_func
	.global MCU__enSetStackActive
 	.type MCU__enSetStackActive, %function
MCU__enSetStackActive:
	push    {r1,r2}
 8000490:	b406      	push	{r1, r2}
    mrs     r1, CONTROL
 8000492:	f3ef 8114 	mrs	r1, CONTROL
    ubfx    r2, r1, #1, #1
 8000496:	f3c1 0240 	ubfx	r2, r1, #1, #1
    bfi     r1, r0, #1, #1
 800049a:	f360 0141 	bfi	r1, r0, #1, #1
    msr     CONTROL, r1
 800049e:	f381 8814 	msr	CONTROL, r1
    dsb
 80004a2:	f3bf 8f4f 	dsb	sy
    isb
 80004a6:	f3bf 8f6f 	isb	sy
    mov     r0, r2
 80004aa:	4610      	mov	r0, r2
	pop     {r1,r2}
 80004ac:	bc06      	pop	{r1, r2}
    bx      lr
 80004ae:	4770      	bx	lr

080004b0 <MCU__enGetStackActive>:
 	.align 	4
    .thumb_func
	.global MCU__enGetStackActive
 	.type MCU__enGetStackActive, %function
MCU__enGetStackActive:
	push    {r1,r2}
 80004b0:	b406      	push	{r1, r2}
    mrs     r1, CONTROL
 80004b2:	f3ef 8114 	mrs	r1, CONTROL
    ubfx    r0, r1, #1, #1
 80004b6:	f3c1 0040 	ubfx	r0, r1, #1, #1
	pop     {r1,r2}
 80004ba:	bc06      	pop	{r1, r2}
    bx      lr
 80004bc:	4770      	bx	lr
 80004be:	bf00      	nop

080004c0 <MCU__vSetPSPValue>:
 	.align 	4
    .thumb_func
	.global MCU__vSetPSPValue
 	.type MCU__vSetPSPValue, %function
MCU__vSetPSPValue:
	msr PSP, r0
 80004c0:	f380 8809 	msr	PSP, r0
	dsb
 80004c4:	f3bf 8f4f 	dsb	sy
	isb
 80004c8:	f3bf 8f6f 	isb	sy
	bx      lr
 80004cc:	4770      	bx	lr
 80004ce:	bf00      	nop

080004d0 <MCU__uxGetPSPValue>:
 	.align 	4
    .thumb_func
	.global MCU__uxGetPSPValue
 	.type MCU__uxGetPSPValue, %function
MCU__uxGetPSPValue:
	mrs     r0, PSP
 80004d0:	f3ef 8009 	mrs	r0, PSP
	bx      lr
 80004d4:	4770      	bx	lr
 80004d6:	bf00      	nop
 80004d8:	f3af 8000 	nop.w
 80004dc:	f3af 8000 	nop.w

080004e0 <MCU__vSetMSPValue>:
 	.align 	4
    .thumb_func
	.global MCU__vSetMSPValue
 	.type MCU__vSetMSPValue, %function
MCU__vSetMSPValue:
	msr     MSP, r0
 80004e0:	f380 8808 	msr	MSP, r0
	dsb
 80004e4:	f3bf 8f4f 	dsb	sy
	isb
 80004e8:	f3bf 8f6f 	isb	sy
	bx      lr
 80004ec:	4770      	bx	lr
 80004ee:	bf00      	nop

080004f0 <MCU__uxGetMSPValue>:
 	.align 	4
    .thumb_func
	.global MCU__uxGetMSPValue
 	.type MCU__uxGetMSPValue, %function
MCU__uxGetMSPValue:
	mrs     r0, MSP
 80004f0:	f3ef 8008 	mrs	r0, MSP
    bx      lr
 80004f4:	4770      	bx	lr
 80004f6:	bf00      	nop
 80004f8:	f3af 8000 	nop.w
 80004fc:	f3af 8000 	nop.w

08000500 <MCU__enSetThreadLevel>:
 	.align 	4
    .thumb_func
	.global MCU__enSetThreadLevel
 	.type MCU__enSetThreadLevel, %function
MCU__enSetThreadLevel:
	push    {r1,r2}
 8000500:	b406      	push	{r1, r2}
	mrs     r1, CONTROL
 8000502:	f3ef 8114 	mrs	r1, CONTROL
  	ubfx    r2, r1, #0, #1
 8000506:	f3c1 0200 	ubfx	r2, r1, #0, #1
  	bfi     r1, r0, #0, #1
 800050a:	f360 0100 	bfi	r1, r0, #0, #1
  	msr     CONTROL, r1
 800050e:	f381 8814 	msr	CONTROL, r1
  	dsb
 8000512:	f3bf 8f4f 	dsb	sy
  	isb
 8000516:	f3bf 8f6f 	isb	sy
  	mov     r0, r2
 800051a:	4610      	mov	r0, r2
	pop     {r1,r2}
 800051c:	bc06      	pop	{r1, r2}
  	bx      lr
 800051e:	4770      	bx	lr

08000520 <MCU__enGetThreadLevel>:
 	.align 	4
    .thumb_func
	.global MCU__enGetThreadLevel
 	.type MCU__enGetThreadLevel, %function
MCU__enGetThreadLevel:
	push    {r1,r2}
 8000520:	b406      	push	{r1, r2}
	mrs     r1, CONTROL
 8000522:	f3ef 8114 	mrs	r1, CONTROL
	ubfx    r0, r1, #0, #1
 8000526:	f3c1 0000 	ubfx	r0, r1, #0, #1
	pop     {r1,r2}
 800052a:	bc06      	pop	{r1, r2}
	bx      lr
 800052c:	4770      	bx	lr
 800052e:	bf00      	nop

08000530 <MCU__uxSetFPUStatusControl>:
 	.align 	4
    .thumb_func
	.global MCU__uxSetFPUStatusControl
 	.type MCU__uxSetFPUStatusControl, %function
MCU__uxSetFPUStatusControl:
	push    {r1,r2}
 8000530:	b406      	push	{r1, r2}
	vmrs    r1, FPSCR
 8000532:	eef1 1a10 	vmrs	r1, fpscr
	vmsr    FPSCR, r0
 8000536:	eee1 0a10 	vmsr	fpscr, r0
	mov     r0, r1
 800053a:	4608      	mov	r0, r1
	pop     {r1,r2}
 800053c:	bc06      	pop	{r1, r2}
	bx      lr
 800053e:	4770      	bx	lr

08000540 <MCU__vSetFPUStatusControl>:
 	.align 	4
    .thumb_func
	.global MCU__vSetFPUStatusControl
 	.type MCU__vSetFPUStatusControl, %function
MCU__vSetFPUStatusControl:
	vmsr    FPSCR, r0
 8000540:	eee1 0a10 	vmsr	fpscr, r0
	bx      lr
 8000544:	4770      	bx	lr
 8000546:	bf00      	nop
 8000548:	f3af 8000 	nop.w
 800054c:	f3af 8000 	nop.w

08000550 <MCU__uxGetFPUStatusControl>:
 	.align 	4
    .thumb_func
	.global MCU__uxGetFPUStatusControl
 	.type MCU__uxGetFPUStatusControl, %function
MCU__uxGetFPUStatusControl:
	vmrs    r0, FPSCR
 8000550:	eef1 0a10 	vmrs	r0, fpscr
	bx      lr
 8000554:	4770      	bx	lr
 8000556:	bf00      	nop
 8000558:	f3af 8000 	nop.w
 800055c:	f3af 8000 	nop.w

08000560 <MCU__uxSetFPUStatusControlMask>:
 	.align 	4
    .thumb_func
	.global MCU__uxSetFPUStatusControlMask
 	.type MCU__uxSetFPUStatusControlMask, %function
MCU__uxSetFPUStatusControlMask:
	push    {r1,r2}
 8000560:	b406      	push	{r1, r2}
	vmrs    r1, FPSCR
 8000562:	eef1 1a10 	vmrs	r1, fpscr
	mov     r2, r1
 8000566:	460a      	mov	r2, r1
	orr     r1, r0
 8000568:	ea41 0100 	orr.w	r1, r1, r0
	vmsr    FPSCR, r1
 800056c:	eee1 1a10 	vmsr	fpscr, r1
	mov     r0, r2
 8000570:	4610      	mov	r0, r2
	pop     {r1,r2}
 8000572:	bc06      	pop	{r1, r2}
	bx      lr
 8000574:	4770      	bx	lr
 8000576:	bf00      	nop
 8000578:	f3af 8000 	nop.w
 800057c:	f3af 8000 	nop.w

08000580 <MCU__uxClearFPUStatusControlMask>:
 	.align 	4
    .thumb_func
	.global MCU__uxClearFPUStatusControlMask
 	.type MCU__uxClearFPUStatusControlMask, %function
MCU__uxClearFPUStatusControlMask:
	push    {r1,r2}
 8000580:	b406      	push	{r1, r2}
	vmrs    r1, FPSCR
 8000582:	eef1 1a10 	vmrs	r1, fpscr
	mov     r2, r1
 8000586:	460a      	mov	r2, r1
	bic     r1, r0
 8000588:	ea21 0100 	bic.w	r1, r1, r0
	vmsr    FPSCR, r1
 800058c:	eee1 1a10 	vmsr	fpscr, r1
	mov     r0, r2
 8000590:	4610      	mov	r0, r2
	pop     {r1,r2}
 8000592:	bc06      	pop	{r1, r2}
	bx      lr
 8000594:	4770      	bx	lr
 8000596:	bf00      	nop
 8000598:	f3af 8000 	nop.w
 800059c:	f3af 8000 	nop.w

080005a0 <MCU__vSetFPUStatusControlMask>:
 	.align 	4
    .thumb_func
	.global MCU__vSetFPUStatusControlMask
 	.type MCU__vSetFPUStatusControlMask, %function
MCU__vSetFPUStatusControlMask:
	push    {r1,r2}
 80005a0:	b406      	push	{r1, r2}
	vmrs    r1, FPSCR
 80005a2:	eef1 1a10 	vmrs	r1, fpscr
	orr     r1, r0
 80005a6:	ea41 0100 	orr.w	r1, r1, r0
	vmsr    FPSCR, r1
 80005aa:	eee1 1a10 	vmsr	fpscr, r1
	pop     {r1,r2}
 80005ae:	bc06      	pop	{r1, r2}
	bx      lr
 80005b0:	4770      	bx	lr
 80005b2:	bf00      	nop
 80005b4:	f3af 8000 	nop.w
 80005b8:	f3af 8000 	nop.w
 80005bc:	f3af 8000 	nop.w

080005c0 <MCU__vClearFPUStatusControlMask>:
 	.align 	4
    .thumb_func
	.global MCU__vClearFPUStatusControlMask
 	.type MCU__vClearFPUStatusControlMask, %function
MCU__vClearFPUStatusControlMask:
	push    {r1,r2}
 80005c0:	b406      	push	{r1, r2}
	vmrs    r1, FPSCR
 80005c2:	eef1 1a10 	vmrs	r1, fpscr
	bic     r1, r0
 80005c6:	ea21 0100 	bic.w	r1, r1, r0
	vmsr    FPSCR, r1
 80005ca:	eee1 1a10 	vmsr	fpscr, r1
	pop     {r1,r2}
 80005ce:	bc06      	pop	{r1, r2}
	bx      lr
 80005d0:	4770      	bx	lr
 80005d2:	bf00      	nop
 80005d4:	f3af 8000 	nop.w
 80005d8:	f3af 8000 	nop.w
 80005dc:	f3af 8000 	nop.w

080005e0 <MCU__uxGetFPUStatusControlMask>:
 	.align 	4
    .thumb_func
	.global MCU__uxGetFPUStatusControlMask
 	.type MCU__uxGetFPUStatusControlMask, %function
MCU__uxGetFPUStatusControlMask:
	push    {r1,r2}
 80005e0:	b406      	push	{r1, r2}
	vmrs    r1, FPSCR
 80005e2:	eef1 1a10 	vmrs	r1, fpscr
	and     r1, r0
 80005e6:	ea01 0100 	and.w	r1, r1, r0
	mov     r0, r1
 80005ea:	4608      	mov	r0, r1
	pop     {r1,r2}
 80005ec:	bc06      	pop	{r1, r2}
	bx      lr
 80005ee:	4770      	bx	lr

080005f0 <MCU__uxSetFPUStatusControlBit>:
 	.align 	4
    .thumb_func
	.global MCU__uxSetFPUStatusControlBit
 	.type MCU__uxSetFPUStatusControlBit, %function
MCU__uxSetFPUStatusControlBit:
	push    {r1-r4}
 80005f0:	b41e      	push	{r1, r2, r3, r4}
	vmrs    r1, FPSCR
 80005f2:	eef1 1a10 	vmrs	r1, fpscr
	mov     r2, r1
 80005f6:	460a      	mov	r2, r1
	lsr     r2, r0
 80005f8:	fa22 f200 	lsr.w	r2, r2, r0
	and     r2, #1
 80005fc:	f002 0201 	and.w	r2, r2, #1
	mov     r3, #1
 8000600:	f04f 0301 	mov.w	r3, #1
	lsl     r3, r0
 8000604:	fa03 f300 	lsl.w	r3, r3, r0
	orr     r1, r3
 8000608:	ea41 0103 	orr.w	r1, r1, r3
	vmsr    FPSCR, r1
 800060c:	eee1 1a10 	vmsr	fpscr, r1
	mov     r0, r2
 8000610:	4610      	mov	r0, r2
	pop     {r1-r4}
 8000612:	bc1e      	pop	{r1, r2, r3, r4}
	bx      lr
 8000614:	4770      	bx	lr
 8000616:	bf00      	nop
 8000618:	f3af 8000 	nop.w
 800061c:	f3af 8000 	nop.w

08000620 <MCU__uxClearFPUStatusControlBit>:
 	.align 	4
    .thumb_func
	.global MCU__uxClearFPUStatusControlBit
 	.type MCU__uxClearFPUStatusControlBit, %function
MCU__uxClearFPUStatusControlBit:
	push    {r1-r4}
 8000620:	b41e      	push	{r1, r2, r3, r4}
	vmrs    r1, FPSCR
 8000622:	eef1 1a10 	vmrs	r1, fpscr
	mov     r2, r1
 8000626:	460a      	mov	r2, r1
	lsr     r2, r0
 8000628:	fa22 f200 	lsr.w	r2, r2, r0
	and     r2, #1
 800062c:	f002 0201 	and.w	r2, r2, #1
	mov     r3, #1
 8000630:	f04f 0301 	mov.w	r3, #1
	lsl     r3, r0
 8000634:	fa03 f300 	lsl.w	r3, r3, r0
	bic     r1, r3
 8000638:	ea21 0103 	bic.w	r1, r1, r3
	vmsr    FPSCR, r1
 800063c:	eee1 1a10 	vmsr	fpscr, r1
	mov     r0, r2
 8000640:	4610      	mov	r0, r2
	pop     {r1-r4}
 8000642:	bc1e      	pop	{r1, r2, r3, r4}
	bx      lr
 8000644:	4770      	bx	lr
 8000646:	bf00      	nop
 8000648:	f3af 8000 	nop.w
 800064c:	f3af 8000 	nop.w

08000650 <MCU__vSetFPUStatusControlBit>:
 	.align 	4
    .thumb_func
	.global MCU__vSetFPUStatusControlBit
 	.type MCU__vSetFPUStatusControlBit, %function
MCU__vSetFPUStatusControlBit:
	push    {r1,r2}
 8000650:	b406      	push	{r1, r2}
	vmrs    r1, FPSCR
 8000652:	eef1 1a10 	vmrs	r1, fpscr
	mov     r2, #1
 8000656:	f04f 0201 	mov.w	r2, #1
	lsl     r2, r0
 800065a:	fa02 f200 	lsl.w	r2, r2, r0
	orr     r1, r2
 800065e:	ea41 0102 	orr.w	r1, r1, r2
	vmsr    FPSCR, r1
 8000662:	eee1 1a10 	vmsr	fpscr, r1
	pop     {r1,r2}
 8000666:	bc06      	pop	{r1, r2}
	bx      lr
 8000668:	4770      	bx	lr
 800066a:	bf00      	nop
 800066c:	f3af 8000 	nop.w

08000670 <MCU__vClearFPUStatusControlBit>:
 	.align 	4
    .thumb_func
	.global MCU__vClearFPUStatusControlBit
 	.type MCU__vClearFPUStatusControlBit, %function
MCU__vClearFPUStatusControlBit:
	push    {r1,r2}
 8000670:	b406      	push	{r1, r2}
	vmrs    r1, FPSCR
 8000672:	eef1 1a10 	vmrs	r1, fpscr
	mov     r2, #1
 8000676:	f04f 0201 	mov.w	r2, #1
	lsl     r2, r0
 800067a:	fa02 f200 	lsl.w	r2, r2, r0
	bic     r1, r2
 800067e:	ea21 0102 	bic.w	r1, r1, r2
	vmsr    FPSCR, r1
 8000682:	eee1 1a10 	vmsr	fpscr, r1
	pop     {r1,r2}
 8000686:	bc06      	pop	{r1, r2}
	bx      lr
 8000688:	4770      	bx	lr
 800068a:	bf00      	nop
 800068c:	f3af 8000 	nop.w

08000690 <MCU__uxGetFPUStatusControlBit>:
 	.align 	4
    .thumb_func
	.global MCU__uxGetFPUStatusControlBit
 	.type MCU__uxGetFPUStatusControlBit, %function
MCU__uxGetFPUStatusControlBit:
	vmrs    r1, FPSCR
 8000690:	eef1 1a10 	vmrs	r1, fpscr
	lsr     r1, r0
 8000694:	fa21 f100 	lsr.w	r1, r1, r0
	mov     r0, r1
 8000698:	4608      	mov	r0, r1
	bx      lr
 800069a:	4770      	bx	lr
 800069c:	0000      	movs	r0, r0
	...

080006a0 <MCU__enDisableGlobalInterrupt>:
 	.align 	4
    .thumb_func
	.global MCU__enDisableGlobalInterrupt
 	.type MCU__enDisableGlobalInterrupt, %function
MCU__enDisableGlobalInterrupt:
	mrs     r0, PRIMASK
 80006a0:	f3ef 8010 	mrs	r0, PRIMASK
	cpsid   i
 80006a4:	b672      	cpsid	i
	dsb
 80006a6:	f3bf 8f4f 	dsb	sy
	isb
 80006aa:	f3bf 8f6f 	isb	sy
	bx      lr
 80006ae:	4770      	bx	lr

080006b0 <MCU__enEnableGlobalInterrupt>:
 	.align 	4
    .thumb_func
	.global MCU__enEnableGlobalInterrupt
 	.type MCU__enEnableGlobalInterrupt, %function
MCU__enEnableGlobalInterrupt:
	mrs     r0, PRIMASK
 80006b0:	f3ef 8010 	mrs	r0, PRIMASK
	cpsie   i
 80006b4:	b662      	cpsie	i
	dsb
 80006b6:	f3bf 8f4f 	dsb	sy
	isb
 80006ba:	f3bf 8f6f 	isb	sy
	bx      lr
 80006be:	4770      	bx	lr

080006c0 <MCU__vSetGlobalInterrupt>:
 	.align 	4
    .thumb_func
	.global MCU__vSetGlobalInterrupt
 	.type MCU__vSetGlobalInterrupt, %function
MCU__vSetGlobalInterrupt:
	msr     PRIMASK, r0
 80006c0:	f380 8810 	msr	PRIMASK, r0
	dsb
 80006c4:	f3bf 8f4f 	dsb	sy
	isb
 80006c8:	f3bf 8f6f 	isb	sy
	bx      lr
 80006cc:	4770      	bx	lr
 80006ce:	bf00      	nop

080006d0 <MCU__enSetGlobalInterrupt>:
 	.align 	4
    .thumb_func
	.global MCU__enSetGlobalInterrupt
 	.type MCU__enSetGlobalInterrupt, %function
MCU__enSetGlobalInterrupt:
	push    {r1,r2}
 80006d0:	b406      	push	{r1, r2}
	mrs     r1, PRIMASK
 80006d2:	f3ef 8110 	mrs	r1, PRIMASK
	msr     PRIMASK, r0
 80006d6:	f380 8810 	msr	PRIMASK, r0
	dsb
 80006da:	f3bf 8f4f 	dsb	sy
	isb
 80006de:	f3bf 8f6f 	isb	sy
	mov     r0, r1
 80006e2:	4608      	mov	r0, r1
	pop     {r1,r2}
 80006e4:	bc06      	pop	{r1, r2}
	bx      lr
 80006e6:	4770      	bx	lr
 80006e8:	f3af 8000 	nop.w
 80006ec:	f3af 8000 	nop.w

080006f0 <MCU__enGetGlobalInterrupt>:
 	.align 	4
    .thumb_func
	.global MCU__enGetGlobalInterrupt
 	.type MCU__enGetGlobalInterrupt, %function
MCU__enGetGlobalInterrupt:
	mrs     r0, PRIMASK
 80006f0:	f3ef 8010 	mrs	r0, PRIMASK
	bx      lr
 80006f4:	4770      	bx	lr
 80006f6:	bf00      	nop
 80006f8:	f3af 8000 	nop.w
 80006fc:	f3af 8000 	nop.w

08000700 <MCU__vSetBasePriorityInterrupt>:
 	.align 	4
    .thumb_func
	.global MCU__vSetBasePriorityInterrupt
 	.type MCU__vSetBasePriorityInterrupt, %function
MCU__vSetBasePriorityInterrupt:
	push    {r1,r2}
 8000700:	b406      	push	{r1, r2}
	and     r1, r0, #0xF
 8000702:	f000 010f 	and.w	r1, r0, #15
	lsl     r1, #0x4
 8000706:	ea4f 1101 	mov.w	r1, r1, lsl #4
	msr     BASEPRI, r1
 800070a:	f381 8811 	msr	BASEPRI, r1
	dsb
 800070e:	f3bf 8f4f 	dsb	sy
	isb
 8000712:	f3bf 8f6f 	isb	sy
	pop     {r1,r2}
 8000716:	bc06      	pop	{r1, r2}
	bx      lr
 8000718:	4770      	bx	lr
 800071a:	bf00      	nop
 800071c:	f3af 8000 	nop.w

08000720 <MCU__enSetBasePriorityInterrupt>:
 	.align 	4
    .thumb_func
	.global MCU__enSetBasePriorityInterrupt
 	.type MCU__enSetBasePriorityInterrupt, %function
MCU__enSetBasePriorityInterrupt:
	push    {r1,r2}
 8000720:	b406      	push	{r1, r2}
	and     r1, r0, #0xF
 8000722:	f000 010f 	and.w	r1, r0, #15
	lsl     r1, #0x4
 8000726:	ea4f 1101 	mov.w	r1, r1, lsl #4
	mrs     r2, BASEPRI
 800072a:	f3ef 8211 	mrs	r2, BASEPRI
	ubfx    r0, r2, #4, #4
 800072e:	f3c2 1003 	ubfx	r0, r2, #4, #4
	msr     BASEPRI, r1
 8000732:	f381 8811 	msr	BASEPRI, r1
	dsb
 8000736:	f3bf 8f4f 	dsb	sy
	isb
 800073a:	f3bf 8f6f 	isb	sy
	pop     {r1,r2}
 800073e:	bc06      	pop	{r1, r2}
	bx      lr
 8000740:	4770      	bx	lr
 8000742:	bf00      	nop
 8000744:	f3af 8000 	nop.w
 8000748:	f3af 8000 	nop.w
 800074c:	f3af 8000 	nop.w

08000750 <MCU__enGetBasePriorityInterrupt>:
 	.align 	4
    .thumb_func
	.global MCU__enGetBasePriorityInterrupt
 	.type MCU__enGetBasePriorityInterrupt, %function
MCU__enGetBasePriorityInterrupt:
	push    {r1,r2}
 8000750:	b406      	push	{r1, r2}
	mrs     r1, BASEPRI
 8000752:	f3ef 8111 	mrs	r1, BASEPRI
	lsr     r0, r1, #0x4
 8000756:	ea4f 1011 	mov.w	r0, r1, lsr #4
	and     r0, #0xF
 800075a:	f000 000f 	and.w	r0, r0, #15
	pop     {r1,r2}
 800075e:	bc06      	pop	{r1, r2}
	bx      lr
 8000760:	4770      	bx	lr
 8000762:	bf00      	nop
 8000764:	f3af 8000 	nop.w
 8000768:	f3af 8000 	nop.w
 800076c:	f3af 8000 	nop.w

08000770 <MCU__enDisableGlobalFault>:
 	.align 	4
    .thumb_func
	.global MCU__enDisableGlobalFault
 	.type MCU__enDisableGlobalFault, %function
MCU__enDisableGlobalFault:
	mrs     r0, FAULTMASK
 8000770:	f3ef 8013 	mrs	r0, FAULTMASK
	cpsid   f
 8000774:	b671      	cpsid	f
	dsb
 8000776:	f3bf 8f4f 	dsb	sy
	isb
 800077a:	f3bf 8f6f 	isb	sy
	bx      lr
 800077e:	4770      	bx	lr

08000780 <MCU__enEnableGlobalFault>:
 	.align 	4
    .thumb_func
	.global MCU__enEnableGlobalFault
 	.type MCU__enEnableGlobalFault, %function
MCU__enEnableGlobalFault:
	mrs     r0, FAULTMASK
 8000780:	f3ef 8013 	mrs	r0, FAULTMASK
	cpsie   f
 8000784:	b661      	cpsie	f
	dsb
 8000786:	f3bf 8f4f 	dsb	sy
	isb
 800078a:	f3bf 8f6f 	isb	sy
	bx      lr
 800078e:	4770      	bx	lr

08000790 <MCU__enSetGlobalFault>:
 	.align 	4
    .thumb_func
	.global MCU__enSetGlobalFault
 	.type MCU__enSetGlobalFault, %function
MCU__enSetGlobalFault:
	push    {r1,r2}
 8000790:	b406      	push	{r1, r2}
	mrs     r1, FAULTMASK
 8000792:	f3ef 8113 	mrs	r1, FAULTMASK
	msr     FAULTMASK, r0
 8000796:	f380 8813 	msr	FAULTMASK, r0
	dsb
 800079a:	f3bf 8f4f 	dsb	sy
	isb
 800079e:	f3bf 8f6f 	isb	sy
	mov     r0, r1
 80007a2:	4608      	mov	r0, r1
	pop     {r1,r2}
 80007a4:	bc06      	pop	{r1, r2}
	bx      lr
 80007a6:	4770      	bx	lr
 80007a8:	f3af 8000 	nop.w
 80007ac:	f3af 8000 	nop.w

080007b0 <MCU__enGetGlobalFault>:
 	.align 	4
    .thumb_func
	.global MCU__enGetGlobalFault
 	.type MCU__enGetGlobalFault, %function
MCU__enGetGlobalFault:
	mrs     r0, FAULTMASK
 80007b0:	f3ef 8013 	mrs	r0, FAULTMASK
	bx      lr
 80007b4:	4770      	bx	lr
 80007b6:	bf00      	nop

080007b8 <main>:
 */

#include <stdint.h>

int main(void)
{
 80007b8:	b480      	push	{r7}
 80007ba:	af00      	add	r7, sp, #0
    /* Loop forever */
	for(;;);
 80007bc:	e7fe      	b.n	80007bc <main+0x4>
	...

080007c0 <ResetISR>:
/* application.*/
/**/
/*******************************************************************************/
void
ResetISR(void)
{
 80007c0:	b580      	push	{r7, lr}
 80007c2:	b086      	sub	sp, #24
 80007c4:	af00      	add	r7, sp, #0

    {__asm volatile(" cpsid i");}
 80007c6:	b672      	cpsid	i
    MCU__vSetPSPValue(&_estack);
 80007c8:	4b27      	ldr	r3, [pc, #156]	; (8000868 <ResetISR+0xa8>)
 80007ca:	4618      	mov	r0, r3
 80007cc:	f7ff fe78 	bl	80004c0 <MCU__vSetPSPValue>
    MCU__enSetStackActive(MCU_enSTACK_PSP);
 80007d0:	2001      	movs	r0, #1
 80007d2:	f7ff fe5d 	bl	8000490 <MCU__enSetStackActive>

    MCU__vSetPSPValue(&_estack);
 80007d6:	4b24      	ldr	r3, [pc, #144]	; (8000868 <ResetISR+0xa8>)
 80007d8:	4618      	mov	r0, r3
 80007da:	f7ff fe71 	bl	80004c0 <MCU__vSetPSPValue>
    MCU__vSetMSPValue(&_main_estack);
 80007de:	4b23      	ldr	r3, [pc, #140]	; (800086c <ResetISR+0xac>)
 80007e0:	4618      	mov	r0, r3
 80007e2:	f7ff fe7d 	bl	80004e0 <MCU__vSetMSPValue>
    /* Copy the ramcode segment initializers from flash to SRAM.*/
    /**/
    {
        UBase_t *pui32SrcRamCode;
        UBase_t *pui32DestRamCode;
        pui32SrcRamCode = &__ramcode_load__;
 80007e6:	4b22      	ldr	r3, [pc, #136]	; (8000870 <ResetISR+0xb0>)
 80007e8:	617b      	str	r3, [r7, #20]
        pui32DestRamCode = &__ramcode_start__;
 80007ea:	4b22      	ldr	r3, [pc, #136]	; (8000874 <ResetISR+0xb4>)
 80007ec:	613b      	str	r3, [r7, #16]
        while(pui32DestRamCode <= &__ramcode_end__)
 80007ee:	e009      	b.n	8000804 <ResetISR+0x44>
        {
            *pui32DestRamCode = *pui32SrcRamCode;
 80007f0:	697b      	ldr	r3, [r7, #20]
 80007f2:	681a      	ldr	r2, [r3, #0]
 80007f4:	693b      	ldr	r3, [r7, #16]
 80007f6:	601a      	str	r2, [r3, #0]
            pui32SrcRamCode += 1UL;
 80007f8:	697b      	ldr	r3, [r7, #20]
 80007fa:	3304      	adds	r3, #4
 80007fc:	617b      	str	r3, [r7, #20]
            pui32DestRamCode += 1UL;
 80007fe:	693b      	ldr	r3, [r7, #16]
 8000800:	3304      	adds	r3, #4
 8000802:	613b      	str	r3, [r7, #16]
        while(pui32DestRamCode <= &__ramcode_end__)
 8000804:	693b      	ldr	r3, [r7, #16]
 8000806:	4a1c      	ldr	r2, [pc, #112]	; (8000878 <ResetISR+0xb8>)
 8000808:	4293      	cmp	r3, r2
 800080a:	d9f1      	bls.n	80007f0 <ResetISR+0x30>
    /* Copy the ramcode segment initializers from flash to SRAM.*/
    /**/
    {
        UBase_t *pui32SrcData;
        UBase_t *pui32DestData;
        pui32SrcData = (UBase_t*) &__data_load__;
 800080c:	4b1b      	ldr	r3, [pc, #108]	; (800087c <ResetISR+0xbc>)
 800080e:	60fb      	str	r3, [r7, #12]
        pui32DestData = (UBase_t*) &__data_start__;
 8000810:	4b1b      	ldr	r3, [pc, #108]	; (8000880 <ResetISR+0xc0>)
 8000812:	60bb      	str	r3, [r7, #8]
        while(pui32DestData <= &__data_end__)
 8000814:	e009      	b.n	800082a <ResetISR+0x6a>
        {
            *pui32DestData = *pui32SrcData;
 8000816:	68fb      	ldr	r3, [r7, #12]
 8000818:	681a      	ldr	r2, [r3, #0]
 800081a:	68bb      	ldr	r3, [r7, #8]
 800081c:	601a      	str	r2, [r3, #0]
            pui32SrcData += 1UL;
 800081e:	68fb      	ldr	r3, [r7, #12]
 8000820:	3304      	adds	r3, #4
 8000822:	60fb      	str	r3, [r7, #12]
            pui32DestData += 1UL;
 8000824:	68bb      	ldr	r3, [r7, #8]
 8000826:	3304      	adds	r3, #4
 8000828:	60bb      	str	r3, [r7, #8]
        while(pui32DestData <= &__data_end__)
 800082a:	68bb      	ldr	r3, [r7, #8]
 800082c:	4a15      	ldr	r2, [pc, #84]	; (8000884 <ResetISR+0xc4>)
 800082e:	4293      	cmp	r3, r2
 8000830:	d9f1      	bls.n	8000816 <ResetISR+0x56>
    /**/
    /* Copy the ramcode segment initializers from flash to SRAM.*/
    /**/
    {
        UBase_t *pui32DestBss;
        pui32DestBss = (UBase_t*) &__bss_start__;
 8000832:	4b15      	ldr	r3, [pc, #84]	; (8000888 <ResetISR+0xc8>)
 8000834:	607b      	str	r3, [r7, #4]
        while(pui32DestBss <= &__bss_end__)
 8000836:	e005      	b.n	8000844 <ResetISR+0x84>
        {
            *pui32DestBss = 0UL;
 8000838:	687b      	ldr	r3, [r7, #4]
 800083a:	2200      	movs	r2, #0
 800083c:	601a      	str	r2, [r3, #0]
            pui32DestBss += 1UL;
 800083e:	687b      	ldr	r3, [r7, #4]
 8000840:	3304      	adds	r3, #4
 8000842:	607b      	str	r3, [r7, #4]
        while(pui32DestBss <= &__bss_end__)
 8000844:	687b      	ldr	r3, [r7, #4]
 8000846:	4a11      	ldr	r2, [pc, #68]	; (800088c <ResetISR+0xcc>)
 8000848:	4293      	cmp	r3, r2
 800084a:	d9f5      	bls.n	8000838 <ResetISR+0x78>
    /* case where main() uses float32_ting-point and the function prologue saves*/
    /* float32_ting-point registers (which will fault if float32_ting-point is not*/
    /* enabled).  Any configuration of the float32_ting-point unit using DriverLib*/
    /* APIs must be done here prior to the float32_ting-point unit being enabled.*/

    FPU__enInit(FPU_enMODULE_0);
 800084c:	2000      	movs	r0, #0
 800084e:	f000 f823 	bl	8000898 <FPU__enInit>
    NVIC__enDisableAllInterrupts(NVIC_enMODULE_0);
 8000852:	2000      	movs	r0, #0
 8000854:	f000 f88e 	bl	8000974 <NVIC__enDisableAllInterrupts>
    /**/
    /* Call the application's entry point.*/
    /**/


    {__asm volatile(" cpsid i");}
 8000858:	b672      	cpsid	i

    main();
 800085a:	f7ff ffad 	bl	80007b8 <main>
}
 800085e:	bf00      	nop
 8000860:	3718      	adds	r7, #24
 8000862:	46bd      	mov	sp, r7
 8000864:	bd80      	pop	{r7, pc}
 8000866:	bf00      	nop
 8000868:	20076000 	.word	0x20076000
 800086c:	2007c000 	.word	0x2007c000
 8000870:	08000af4 	.word	0x08000af4
 8000874:	2007c000 	.word	0x2007c000
 8000878:	2007c118 	.word	0x2007c118
 800087c:	08000af4 	.word	0x08000af4
 8000880:	20020000 	.word	0x20020000
 8000884:	20020000 	.word	0x20020000
 8000888:	20020000 	.word	0x20020000
 800088c:	2002001c 	.word	0x2002001c

08000890 <IntDefaultHandler>:


static void
IntDefaultHandler(void)
{
 8000890:	b480      	push	{r7}
 8000892:	af00      	add	r7, sp, #0
    /**/
    /* Go into an infinite loop.*/
    /**/
    while(1U)
 8000894:	e7fe      	b.n	8000894 <IntDefaultHandler+0x4>
	...

08000898 <FPU__enInit>:
#include <xDriver_MCU/Core/FPU/App/xHeader/FPU_Init.h>

#include <xDriver_MCU/Core/FPU/Driver/FPU_Driver.h>

FPU_nERROR FPU__enInit(FPU_nMODULE enModuleArg)
{
 8000898:	b538      	push	{r3, r4, r5, lr}
    FPU_nERROR enErrorReg;
    enErrorReg = FPU__enSetAccessType(enModuleArg, FPU_enACCESS_FULL);
 800089a:	2103      	movs	r1, #3
{
 800089c:	4605      	mov	r5, r0
    enErrorReg = FPU__enSetAccessType(enModuleArg, FPU_enACCESS_FULL);
 800089e:	f000 f825 	bl	80008ec <FPU__enSetAccessType>
    if(FPU_enERROR_OK == enErrorReg)
 80008a2:	4604      	mov	r4, r0
 80008a4:	b108      	cbz	r0, 80008aa <FPU__enInit+0x12>
        FPU__vSetHalfPrecision(enModuleArg, FPU_enHALF_PRECISION_IEEE);
        FPU__vSetNAN(enModuleArg, FPU_enNAN_PROPAGATE);
        FPU__vSetRoundingMode(enModuleArg, FPU_enROUNDING_NEAREST);
    }
    return (enErrorReg);
}
 80008a6:	4620      	mov	r0, r4
 80008a8:	bd38      	pop	{r3, r4, r5, pc}
        enErrorReg = FPU__enSetAutoPreservationState(enModuleArg, FPU_enSTATE_ENA);
 80008aa:	2101      	movs	r1, #1
 80008ac:	4628      	mov	r0, r5
 80008ae:	f000 f831 	bl	8000914 <FPU__enSetAutoPreservationState>
    if(FPU_enERROR_OK == enErrorReg)
 80008b2:	4604      	mov	r4, r0
 80008b4:	2800      	cmp	r0, #0
 80008b6:	d1f6      	bne.n	80008a6 <FPU__enInit+0xe>
        enErrorReg = FPU__enSetLazyPreservationState(enModuleArg, FPU_enSTATE_ENA);
 80008b8:	2101      	movs	r1, #1
 80008ba:	4628      	mov	r0, r5
 80008bc:	f000 f83e 	bl	800093c <FPU__enSetLazyPreservationState>
    if(FPU_enERROR_OK == enErrorReg)
 80008c0:	4604      	mov	r4, r0
 80008c2:	2800      	cmp	r0, #0
 80008c4:	d1ef      	bne.n	80008a6 <FPU__enInit+0xe>
        FPU__vSetMode(enModuleArg, FPU_enMODE_DENORMAL);
 80008c6:	4601      	mov	r1, r0
 80008c8:	4628      	mov	r0, r5
 80008ca:	f000 f847 	bl	800095c <FPU__vSetMode>
        FPU__vSetHalfPrecision(enModuleArg, FPU_enHALF_PRECISION_IEEE);
 80008ce:	4621      	mov	r1, r4
 80008d0:	4628      	mov	r0, r5
 80008d2:	f000 f82f 	bl	8000934 <FPU__vSetHalfPrecision>
        FPU__vSetNAN(enModuleArg, FPU_enNAN_PROPAGATE);
 80008d6:	4621      	mov	r1, r4
 80008d8:	4628      	mov	r0, r5
 80008da:	f000 f843 	bl	8000964 <FPU__vSetNAN>
        FPU__vSetRoundingMode(enModuleArg, FPU_enROUNDING_NEAREST);
 80008de:	4628      	mov	r0, r5
 80008e0:	4621      	mov	r1, r4
 80008e2:	f000 f843 	bl	800096c <FPU__vSetRoundingMode>
}
 80008e6:	4620      	mov	r0, r4
 80008e8:	bd38      	pop	{r3, r4, r5, pc}
 80008ea:	bf00      	nop

080008ec <FPU__enSetAccessType>:
#include <xDriver_MCU/Common/MCU_Common.h>
#include <xDriver_MCU/Core/FPU/Peripheral/FPU_Peripheral.h>
#include <xDriver_MCU/Core/FPU/Driver/Intrinsics/Primitives/FPU_Primitives.h>

FPU_nERROR FPU__enSetAccessType(FPU_nMODULE enModuleArg, FPU_nACCESS enAccessTypeArg)
{
 80008ec:	b530      	push	{r4, r5, lr}
    uxAccessMask = FPU_CPACR_CP11_MASK;
    uxAccessMask <<= FPU_CPACR_R_CP11_BIT - FPU_CPACR_R_CP10_BIT;
    uxAccessMask |= FPU_CPACR_CP10_MASK;

    uxAccess = (UBase_t) enAccessTypeArg;
    uxAccess &= FPU_CPACR_CP11_MASK;
 80008ee:	f001 0303 	and.w	r3, r1, #3
{
 80008f2:	b085      	sub	sp, #20
    uxAccess <<= FPU_CPACR_R_CP11_BIT - FPU_CPACR_R_CP10_BIT;
    uxAccess |= uxAccess1;

    stRegister.uxShift = FPU_CPACR_R_CP10_BIT;
    stRegister.uxMask = (UBase_t) uxAccessMask;
    stRegister.uptrAddress = FPU_CPACR_OFFSET;
 80008f4:	f640 5288 	movw	r2, #3464	; 0xd88
    stRegister.uxShift = FPU_CPACR_R_CP10_BIT;
 80008f8:	2514      	movs	r5, #20
    uxAccess |= uxAccess1;
 80008fa:	ea43 0383 	orr.w	r3, r3, r3, lsl #2
    stRegister.uxMask = (UBase_t) uxAccessMask;
 80008fe:	240f      	movs	r4, #15
    stRegister.uxValue = (UBase_t) uxAccess;
    enErrorReg = FPU__enWriteRegister(enModuleArg, &stRegister);
 8000900:	4669      	mov	r1, sp
    stRegister.uptrAddress = FPU_CPACR_OFFSET;
 8000902:	9203      	str	r2, [sp, #12]
    stRegister.uxValue = (UBase_t) uxAccess;
 8000904:	9300      	str	r3, [sp, #0]
    stRegister.uxMask = (UBase_t) uxAccessMask;
 8000906:	e9cd 4501 	strd	r4, r5, [sp, #4]
    enErrorReg = FPU__enWriteRegister(enModuleArg, &stRegister);
 800090a:	f000 f871 	bl	80009f0 <FPU__enWriteRegister>

    return (enErrorReg);
}
 800090e:	b005      	add	sp, #20
 8000910:	bd30      	pop	{r4, r5, pc}
 8000912:	bf00      	nop

08000914 <FPU__enSetAutoPreservationState>:
#include <xDriver_MCU/Core/FPU/Peripheral/FPU_Peripheral.h>
#include <xDriver_MCU/Core/FPU/Driver/Intrinsics/Primitives/FPU_Primitives.h>

FPU_nERROR FPU__enSetAutoPreservationState(FPU_nMODULE enModuleArg,
                                           FPU_nSTATE enStateArg)
{
 8000914:	b510      	push	{r4, lr}
 8000916:	b084      	sub	sp, #16
    FPU_Register_t stRegister;
    FPU_nERROR enErrorReg;

    stRegister.uxShift = FPU_CCR_R_ASPEN_BIT;
    stRegister.uxMask = FPU_CCR_ASPEN_MASK;
 8000918:	2201      	movs	r2, #1
    stRegister.uptrAddress = FPU_CCR_OFFSET;
 800091a:	f640 7334 	movw	r3, #3892	; 0xf34
    stRegister.uxShift = FPU_CCR_R_ASPEN_BIT;
 800091e:	241f      	movs	r4, #31
    stRegister.uxValue = (UBase_t) enStateArg;
 8000920:	9100      	str	r1, [sp, #0]
    enErrorReg = FPU__enWriteRegister(enModuleArg, &stRegister);
 8000922:	4669      	mov	r1, sp
    stRegister.uxShift = FPU_CCR_R_ASPEN_BIT;
 8000924:	9402      	str	r4, [sp, #8]
    stRegister.uxMask = FPU_CCR_ASPEN_MASK;
 8000926:	9201      	str	r2, [sp, #4]
    stRegister.uptrAddress = FPU_CCR_OFFSET;
 8000928:	9303      	str	r3, [sp, #12]
    enErrorReg = FPU__enWriteRegister(enModuleArg, &stRegister);
 800092a:	f000 f861 	bl	80009f0 <FPU__enWriteRegister>

    return (enErrorReg);
}
 800092e:	b004      	add	sp, #16
 8000930:	bd10      	pop	{r4, pc}
 8000932:	bf00      	nop

08000934 <FPU__vSetHalfPrecision>:
#include <xDriver_MCU/Core/FPU/Driver/Intrinsics/Primitives/FPU_Primitives.h>

void FPU__vSetHalfPrecision(FPU_nMODULE enModuleArg,
                                   FPU_nHALF_PRECISION enHalfPrecisionArg)
{
    MCU__vFPUStatusControlMask(FPU_DSCR_R_AHP_MASK, (UBase_t) enHalfPrecisionArg);
 8000934:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 8000938:	f000 b854 	b.w	80009e4 <MCU__vFPUStatusControlMask>

0800093c <FPU__enSetLazyPreservationState>:
#include <xDriver_MCU/Core/FPU/Peripheral/FPU_Peripheral.h>
#include <xDriver_MCU/Core/FPU/Driver/Intrinsics/Primitives/FPU_Primitives.h>

FPU_nERROR FPU__enSetLazyPreservationState(FPU_nMODULE enModuleArg,
                                           FPU_nSTATE enStateArg)
{
 800093c:	b510      	push	{r4, lr}
 800093e:	b084      	sub	sp, #16
    FPU_Register_t stRegister;
    FPU_nERROR enErrorReg;

    stRegister.uxShift = FPU_CCR_R_LSPEN_BIT;
    stRegister.uxMask = FPU_CCR_LSPEN_MASK;
 8000940:	2201      	movs	r2, #1
    stRegister.uptrAddress = FPU_CCR_OFFSET;
 8000942:	f640 7334 	movw	r3, #3892	; 0xf34
    stRegister.uxShift = FPU_CCR_R_LSPEN_BIT;
 8000946:	241e      	movs	r4, #30
    stRegister.uxValue = (UBase_t) enStateArg;
 8000948:	9100      	str	r1, [sp, #0]
    enErrorReg = FPU__enWriteRegister(enModuleArg, &stRegister);
 800094a:	4669      	mov	r1, sp
    stRegister.uxShift = FPU_CCR_R_LSPEN_BIT;
 800094c:	9402      	str	r4, [sp, #8]
    stRegister.uxMask = FPU_CCR_LSPEN_MASK;
 800094e:	9201      	str	r2, [sp, #4]
    stRegister.uptrAddress = FPU_CCR_OFFSET;
 8000950:	9303      	str	r3, [sp, #12]
    enErrorReg = FPU__enWriteRegister(enModuleArg, &stRegister);
 8000952:	f000 f84d 	bl	80009f0 <FPU__enWriteRegister>

    return (enErrorReg);
}
 8000956:	b004      	add	sp, #16
 8000958:	bd10      	pop	{r4, pc}
 800095a:	bf00      	nop

0800095c <FPU__vSetMode>:
#include <xDriver_MCU/Core/FPU/Peripheral/FPU_Peripheral.h>
#include <xDriver_MCU/Core/FPU/Driver/Intrinsics/Primitives/FPU_Primitives.h>

void FPU__vSetMode(FPU_nMODULE enModuleArg, FPU_nMODE enModeArg)
{
    MCU__vFPUStatusControlMask(FPU_DSCR_R_FZ_MASK, (UBase_t) enModeArg);
 800095c:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
 8000960:	f000 b840 	b.w	80009e4 <MCU__vFPUStatusControlMask>

08000964 <FPU__vSetNAN>:
#include <xDriver_MCU/Core/FPU/Peripheral/FPU_Peripheral.h>
#include <xDriver_MCU/Core/FPU/Driver/Intrinsics/Primitives/FPU_Primitives.h>

void FPU__vSetNAN(FPU_nMODULE enModuleArg, FPU_nNAN enNANArg)
{
    MCU__vFPUStatusControlMask(FPU_DSCR_R_DN_MASK, (UBase_t) enNANArg);
 8000964:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 8000968:	f000 b83c 	b.w	80009e4 <MCU__vFPUStatusControlMask>

0800096c <FPU__vSetRoundingMode>:
#include <xDriver_MCU/Core/FPU/Driver/Intrinsics/Primitives/FPU_Primitives.h>

void FPU__vSetRoundingMode(FPU_nMODULE enModuleArg,
                                   FPU_nROUNDING enRoundingArg)
{
    MCU__vFPUStatusControlMask(FPU_DSCR_R_RMODE_MASK, (UBase_t) enRoundingArg);
 800096c:	f44f 0040 	mov.w	r0, #12582912	; 0xc00000
 8000970:	f000 b838 	b.w	80009e4 <MCU__vFPUStatusControlMask>

08000974 <NVIC__enDisableAllInterrupts>:
#include <xDriver_MCU/Core/NVIC/Driver/xHeader/NVIC_DeInitInterrupts.h>

#include <xDriver_MCU/Core/NVIC/Driver/xHeader/NVIC_Enable.h>

NVIC_nERROR NVIC__enDisableAllInterrupts(NVIC_nMODULE enModuleArg)
{
 8000974:	b538      	push	{r3, r4, r5, lr}

    NVIC_nERROR enErrorReg;
    UBase_t uxVectorNum;

    for(uxVectorNum = 0U; uxVectorNum < (UBase_t) NVIC_enVECTOR_MAX; uxVectorNum++)
 8000976:	2400      	movs	r4, #0
{
 8000978:	4605      	mov	r5, r0
 800097a:	e001      	b.n	8000980 <NVIC__enDisableAllInterrupts+0xc>
    for(uxVectorNum = 0U; uxVectorNum < (UBase_t) NVIC_enVECTOR_MAX; uxVectorNum++)
 800097c:	2c6e      	cmp	r4, #110	; 0x6e
 800097e:	d006      	beq.n	800098e <NVIC__enDisableAllInterrupts+0x1a>
    {
        enErrorReg = NVIC__enDisableVector(enModuleArg, (NVIC_nVECTOR) uxVectorNum);
 8000980:	4621      	mov	r1, r4
 8000982:	4628      	mov	r0, r5
    for(uxVectorNum = 0U; uxVectorNum < (UBase_t) NVIC_enVECTOR_MAX; uxVectorNum++)
 8000984:	3401      	adds	r4, #1
        enErrorReg = NVIC__enDisableVector(enModuleArg, (NVIC_nVECTOR) uxVectorNum);
 8000986:	f000 f803 	bl	8000990 <NVIC__enDisableVector>
        if(NVIC_enERROR_OK != enErrorReg)
 800098a:	2800      	cmp	r0, #0
 800098c:	d0f6      	beq.n	800097c <NVIC__enDisableAllInterrupts+0x8>
            break;
        }
    }

    return (enErrorReg);
}
 800098e:	bd38      	pop	{r3, r4, r5, pc}

08000990 <NVIC__enDisableVector>:
NVIC_nERROR NVIC__enSetVectorState(NVIC_nMODULE enModuleArg, NVIC_nVECTOR enVectorArg, NVIC_nSTATE enStateArg)
{
    NVIC_nERROR enErrorReg;
    if(NVIC_enSTATE_DIS == enStateArg)
    {
        enErrorReg = NVIC__enSetWriteValue(enModuleArg, enVectorArg, NVIC_ICER_OFFSET, (UBase_t) NVIC_enSTATE_ENA);
 8000990:	2301      	movs	r3, #1
 8000992:	f44f 72c0 	mov.w	r2, #384	; 0x180
 8000996:	f000 b801 	b.w	800099c <NVIC__enSetWriteValue>
 800099a:	bf00      	nop

0800099c <NVIC__enSetWriteValue>:
#include <xDriver_MCU/Common/MCU_Common.h>
#include <xDriver_MCU/Core/NVIC/Peripheral/NVIC_Peripheral.h>
#include <xDriver_MCU/Core/NVIC/Driver/Intrinsics/Primitives/NVIC_Primitives.h>

NVIC_nERROR NVIC__enSetWriteValue(NVIC_nMODULE enModuleArg, NVIC_nVECTOR enVectorArg, uintptr_t uptrRegisterOffsetArg, UBase_t uxValueArg)
{
 800099c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800099e:	460c      	mov	r4, r1
 80009a0:	b085      	sub	sp, #20
 80009a2:	4606      	mov	r6, r0
    NVIC_Register_t stRegister;
    NVIC_nERROR enErrorReg;
    UBase_t uxVectorBit;
    UBase_t uxVectorIndex;

    enErrorReg = (NVIC_nERROR) MCU__enCheckParams((UBase_t) enVectorArg, (UBase_t) NVIC_enVECTOR_MAX);
 80009a4:	216e      	movs	r1, #110	; 0x6e
 80009a6:	4620      	mov	r0, r4
{
 80009a8:	4617      	mov	r7, r2
 80009aa:	461d      	mov	r5, r3
    enErrorReg = (NVIC_nERROR) MCU__enCheckParams((UBase_t) enVectorArg, (UBase_t) NVIC_enVECTOR_MAX);
 80009ac:	f000 f814 	bl	80009d8 <MCU__enCheckParams>
    if(NVIC_enERROR_OK == enErrorReg)
 80009b0:	b108      	cbz	r0, 80009b6 <NVIC__enSetWriteValue+0x1a>
        stRegister.uptrAddress = (UBase_t) uptrRegisterOffsetArg;
        stRegister.uxValue = uxValueArg;
        enErrorReg = NVIC__enWriteRegister(enModuleArg, &stRegister);
    }
    return (enErrorReg);
}
 80009b2:	b005      	add	sp, #20
 80009b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
        uxVectorIndex >>= 5UL;
 80009b6:	0962      	lsrs	r2, r4, #5
        stRegister.uxMask = 0x1UL;
 80009b8:	2301      	movs	r3, #1
        uxVectorBit %= 32UL;
 80009ba:	f004 041f 	and.w	r4, r4, #31
        enErrorReg = NVIC__enWriteRegister(enModuleArg, &stRegister);
 80009be:	4669      	mov	r1, sp
        uptrRegisterOffsetArg += uxVectorIndex;
 80009c0:	eb07 0282 	add.w	r2, r7, r2, lsl #2
        enErrorReg = NVIC__enWriteRegister(enModuleArg, &stRegister);
 80009c4:	4630      	mov	r0, r6
        stRegister.uxValue = uxValueArg;
 80009c6:	9500      	str	r5, [sp, #0]
        stRegister.uxShift = (UBase_t) uxVectorBit;
 80009c8:	9402      	str	r4, [sp, #8]
        stRegister.uptrAddress = (UBase_t) uptrRegisterOffsetArg;
 80009ca:	9203      	str	r2, [sp, #12]
        stRegister.uxMask = 0x1UL;
 80009cc:	9301      	str	r3, [sp, #4]
        enErrorReg = NVIC__enWriteRegister(enModuleArg, &stRegister);
 80009ce:	f000 f82b 	bl	8000a28 <NVIC__enWriteRegister>
}
 80009d2:	b005      	add	sp, #20
 80009d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80009d6:	bf00      	nop

080009d8 <MCU__enCheckParams>:
    else
    {
        enErrorReg = MCU_enERROR_OK;
    }
    return (enErrorReg);
}
 80009d8:	4281      	cmp	r1, r0
 80009da:	bf94      	ite	ls
 80009dc:	2003      	movls	r0, #3
 80009de:	2000      	movhi	r0, #0
 80009e0:	4770      	bx	lr
 80009e2:	bf00      	nop

080009e4 <MCU__vFPUStatusControlMask>:
    return (uxValueReg);
}

void MCU__vFPUStatusControlMask(UBase_t uxBitMaskArg, UBase_t uxValueArg)
{
    if(0U == uxValueArg)
 80009e4:	b909      	cbnz	r1, 80009ea <MCU__vFPUStatusControlMask+0x6>
    {
        MCU__uxClearFPUStatusControlMask(uxBitMaskArg);
 80009e6:	f7ff bdcb 	b.w	8000580 <MCU__uxClearFPUStatusControlMask>
    }
    else
    {
        MCU__uxSetFPUStatusControlMask(uxBitMaskArg);
 80009ea:	f7ff bdb9 	b.w	8000560 <MCU__uxSetFPUStatusControlMask>
 80009ee:	bf00      	nop

080009f0 <FPU__enWriteRegister>:
FPU_nERROR FPU__enWriteRegister(FPU_nMODULE enModuleArg, FPU_Register_t* pstRegisterDataArg)
{
    uintptr_t uptrModuleBase;
    FPU_nERROR enErrorReg;
    enErrorReg = FPU_enERROR_OK;
    if(0UL == (uintptr_t) pstRegisterDataArg)
 80009f0:	b199      	cbz	r1, 8000a1a <FPU__enWriteRegister+0x2a>
{
 80009f2:	b538      	push	{r3, r4, r5, lr}
 80009f4:	460c      	mov	r4, r1
    {
        enErrorReg = FPU_enERROR_POINTER;
    }
    if(FPU_enERROR_OK == enErrorReg)
    {
        enErrorReg = (FPU_nERROR) MCU__enCheckParams((UBase_t) enModuleArg, (UBase_t) FPU_enMODULE_MAX);
 80009f6:	2101      	movs	r1, #1
 80009f8:	4605      	mov	r5, r0
 80009fa:	f7ff ffed 	bl	80009d8 <MCU__enCheckParams>
    }
    if(FPU_enERROR_OK == enErrorReg)
 80009fe:	b958      	cbnz	r0, 8000a18 <FPU__enWriteRegister+0x28>
    {
        uptrModuleBase = FPU__uptrBlockBaseAddress(enModuleArg);
 8000a00:	4628      	mov	r0, r5
 8000a02:	f000 f80d 	bl	8000a20 <FPU__uptrBlockBaseAddress>
        pstRegisterDataArg->uptrAddress += uptrModuleBase;
 8000a06:	68e3      	ldr	r3, [r4, #12]
        uptrModuleBase = FPU__uptrBlockBaseAddress(enModuleArg);
 8000a08:	4602      	mov	r2, r0
        enErrorReg = (FPU_nERROR) MCU__enWriteRegisterISB(pstRegisterDataArg);
 8000a0a:	4620      	mov	r0, r4
        pstRegisterDataArg->uptrAddress += uptrModuleBase;
 8000a0c:	4413      	add	r3, r2
 8000a0e:	60e3      	str	r3, [r4, #12]
    }
    return (enErrorReg);
}
 8000a10:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        enErrorReg = (FPU_nERROR) MCU__enWriteRegisterISB(pstRegisterDataArg);
 8000a14:	f000 b83e 	b.w	8000a94 <MCU__enWriteRegisterISB>
}
 8000a18:	bd38      	pop	{r3, r4, r5, pc}
        enErrorReg = FPU_enERROR_POINTER;
 8000a1a:	2001      	movs	r0, #1
}
 8000a1c:	4770      	bx	lr
 8000a1e:	bf00      	nop

08000a20 <FPU__uptrBlockBaseAddress>:
    uintptr_t FPU_BLOCK_BASE[(UBase_t) FPU_enMODULE_MAX] =
    {
     FPU_BASE
    };
    return (FPU_BLOCK_BASE[(UBase_t) enModuleArg]);
}
 8000a20:	f04f 20e0 	mov.w	r0, #3758153728	; 0xe000e000
 8000a24:	4770      	bx	lr
 8000a26:	bf00      	nop

08000a28 <NVIC__enWriteRegister>:
{
    uintptr_t uptrModuleBase;
    NVIC_nERROR enErrorReg;

    enErrorReg = NVIC_enERROR_OK;
    if(0UL == (uintptr_t) pstRegisterDataArg)
 8000a28:	b199      	cbz	r1, 8000a52 <NVIC__enWriteRegister+0x2a>
{
 8000a2a:	b538      	push	{r3, r4, r5, lr}
 8000a2c:	460c      	mov	r4, r1
    {
        enErrorReg = NVIC_enERROR_POINTER;
    }
    if(NVIC_enERROR_OK == enErrorReg)
    {
        enErrorReg = (NVIC_nERROR) MCU__enCheckParams((UBase_t) enModuleArg, (UBase_t) NVIC_enMODULE_MAX);
 8000a2e:	2101      	movs	r1, #1
 8000a30:	4605      	mov	r5, r0
 8000a32:	f7ff ffd1 	bl	80009d8 <MCU__enCheckParams>
    }
    if(NVIC_enERROR_OK == enErrorReg)
 8000a36:	b958      	cbnz	r0, 8000a50 <NVIC__enWriteRegister+0x28>
    {
        uptrModuleBase = NVIC__uptrBlockBaseAddress(enModuleArg);
 8000a38:	4628      	mov	r0, r5
 8000a3a:	f000 f80d 	bl	8000a58 <NVIC__uptrBlockBaseAddress>
        pstRegisterDataArg->uptrAddress += uptrModuleBase;
 8000a3e:	68e3      	ldr	r3, [r4, #12]
        uptrModuleBase = NVIC__uptrBlockBaseAddress(enModuleArg);
 8000a40:	4602      	mov	r2, r0
        enErrorReg = (NVIC_nERROR) MCU__enWriteRegister(pstRegisterDataArg);
 8000a42:	4620      	mov	r0, r4
        pstRegisterDataArg->uptrAddress += uptrModuleBase;
 8000a44:	4413      	add	r3, r2
 8000a46:	60e3      	str	r3, [r4, #12]
    }

    return (enErrorReg);
}
 8000a48:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        enErrorReg = (NVIC_nERROR) MCU__enWriteRegister(pstRegisterDataArg);
 8000a4c:	f000 b808 	b.w	8000a60 <MCU__enWriteRegister>
}
 8000a50:	bd38      	pop	{r3, r4, r5, pc}
        enErrorReg = NVIC_enERROR_POINTER;
 8000a52:	2001      	movs	r0, #1
}
 8000a54:	4770      	bx	lr
 8000a56:	bf00      	nop

08000a58 <NVIC__uptrBlockBaseAddress>:
    uintptr_t NVIC_BLOCK_BASE[(UBase_t) NVIC_enMODULE_MAX] =
    {
     NVIC_BASE
    };
    return (NVIC_BLOCK_BASE[(UBase_t) enModuleArg]);
}
 8000a58:	f04f 20e0 	mov.w	r0, #3758153728	; 0xe000e000
 8000a5c:	4770      	bx	lr
 8000a5e:	bf00      	nop

08000a60 <MCU__enWriteRegister>:
    MCU_nSTATE enStatus;
    MCU_nERROR enErrorReg;
    UBase_t uxRegisterShift;

    enErrorReg = MCU_enERROR_OK;
    if(0U == (uintptr_t) pstRegisterDataArg)
 8000a60:	b1a8      	cbz	r0, 8000a8e <MCU__enWriteRegister+0x2e>
{
 8000a62:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        enErrorReg = MCU_enERROR_POINTER;
    }
    if(MCU_enERROR_OK == enErrorReg)
    {
        uxRegisterValue = pstRegisterDataArg->uxValue;
        uxRegisterMask = pstRegisterDataArg->uxMask;
 8000a64:	e9d0 4500 	ldrd	r4, r5, [r0]
        uxRegisterShift = pstRegisterDataArg->uxShift;
        uptrRegisterAddress = pstRegisterDataArg->uptrAddress;
 8000a68:	e9d0 7602 	ldrd	r7, r6, [r0, #8]

        uxReg = uxRegisterValue;
        enStatus = MCU__enDisableGlobalInterrupt();
 8000a6c:	f7ff fe18 	bl	80006a0 <MCU__enDisableGlobalInterrupt>
        puxRegisterAddress = (volatile UBase_t*) uptrRegisterAddress;
        if(MCU_MASK_BASE != uxRegisterMask)
 8000a70:	1c6b      	adds	r3, r5, #1
 8000a72:	d007      	beq.n	8000a84 <MCU__enWriteRegister+0x24>
        {
            uxReg = *puxRegisterAddress;
            uxRegisterValue &= uxRegisterMask;
 8000a74:	402c      	ands	r4, r5
            uxReg = *puxRegisterAddress;
 8000a76:	6833      	ldr	r3, [r6, #0]
            if(0U != uxRegisterShift)
 8000a78:	b10f      	cbz	r7, 8000a7e <MCU__enWriteRegister+0x1e>
            {
                uxRegisterValue <<= uxRegisterShift;
 8000a7a:	40bc      	lsls	r4, r7
                uxRegisterMask <<= uxRegisterShift;
 8000a7c:	40bd      	lsls	r5, r7
            }
            uxReg &= ~uxRegisterMask;
 8000a7e:	ea23 0505 	bic.w	r5, r3, r5
            uxReg |= uxRegisterValue;
 8000a82:	432c      	orrs	r4, r5
        }
        *puxRegisterAddress = (UBase_t) uxReg;
 8000a84:	6034      	str	r4, [r6, #0]
        (void) MCU__vSetGlobalInterrupt(enStatus);
 8000a86:	f7ff fe1b 	bl	80006c0 <MCU__vSetGlobalInterrupt>
    enErrorReg = MCU_enERROR_OK;
 8000a8a:	2000      	movs	r0, #0
    }

    return (enErrorReg);
}
 8000a8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        enErrorReg = MCU_enERROR_POINTER;
 8000a8e:	2001      	movs	r0, #1
}
 8000a90:	4770      	bx	lr
 8000a92:	bf00      	nop

08000a94 <MCU__enWriteRegisterISB>:
    MCU_nSTATE enStatus;
    MCU_nERROR enErrorReg;
    UBase_t uxRegisterShift;

    enErrorReg = MCU_enERROR_OK;
    if(0U == (uintptr_t) pstRegisterDataArg)
 8000a94:	b1d8      	cbz	r0, 8000ace <MCU__enWriteRegisterISB+0x3a>
{
 8000a96:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        enErrorReg = MCU_enERROR_POINTER;
    }
    if(MCU_enERROR_OK == enErrorReg)
    {
        uxRegisterValue = pstRegisterDataArg->uxValue;
        uxRegisterMask = pstRegisterDataArg->uxMask;
 8000a98:	e9d0 4500 	ldrd	r4, r5, [r0]
        uxRegisterShift = pstRegisterDataArg->uxShift;
        uptrRegisterAddress = pstRegisterDataArg->uptrAddress;
 8000a9c:	e9d0 7602 	ldrd	r7, r6, [r0, #8]

        uxReg = uxRegisterValue;
        enStatus = MCU__enDisableGlobalInterrupt();
 8000aa0:	f7ff fdfe 	bl	80006a0 <MCU__enDisableGlobalInterrupt>
        puxRegisterAddress = (volatile UBase_t*) uptrRegisterAddress;
        if(MCU_MASK_BASE != uxRegisterMask)
 8000aa4:	1c6b      	adds	r3, r5, #1
 8000aa6:	d007      	beq.n	8000ab8 <MCU__enWriteRegisterISB+0x24>
        {
            uxReg = *puxRegisterAddress;
            uxRegisterValue &= uxRegisterMask;
 8000aa8:	402c      	ands	r4, r5
            uxReg = *puxRegisterAddress;
 8000aaa:	6833      	ldr	r3, [r6, #0]
            if(0U != uxRegisterShift)
 8000aac:	b10f      	cbz	r7, 8000ab2 <MCU__enWriteRegisterISB+0x1e>
            {
                uxRegisterValue <<= uxRegisterShift;
 8000aae:	40bc      	lsls	r4, r7
                uxRegisterMask <<= uxRegisterShift;
 8000ab0:	40bd      	lsls	r5, r7
            }
            uxReg &= ~uxRegisterMask;
 8000ab2:	ea23 0505 	bic.w	r5, r3, r5
            uxReg |= uxRegisterValue;
 8000ab6:	432c      	orrs	r4, r5
        }
        MCU__vDataSyncBarrier();
 8000ab8:	f3bf 8f4f 	dsb	sy
        *puxRegisterAddress = (UBase_t) uxReg;
 8000abc:	6034      	str	r4, [r6, #0]
        MCU__vDataSyncBarrier();
 8000abe:	f3bf 8f4f 	dsb	sy
        MCU__vInstructionSyncBarrier();
 8000ac2:	f3bf 8f6f 	isb	sy
        (void) MCU__vSetGlobalInterrupt(enStatus);
 8000ac6:	f7ff fdfb 	bl	80006c0 <MCU__vSetGlobalInterrupt>
    enErrorReg = MCU_enERROR_OK;
 8000aca:	2000      	movs	r0, #0
    }

    return (enErrorReg);
}
 8000acc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        enErrorReg = MCU_enERROR_POINTER;
 8000ace:	2001      	movs	r0, #1
}
 8000ad0:	4770      	bx	lr
 8000ad2:	bf00      	nop

Disassembly of section .init:

08000ad4 <_init>:
 8000ad4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000ad6:	bf00      	nop
 8000ad8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8000ada:	bc08      	pop	{r3}
 8000adc:	469e      	mov	lr, r3
 8000ade:	4770      	bx	lr

Disassembly of section .finit:

08000ae0 <_fini>:
 8000ae0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000ae2:	bf00      	nop

08000ae4 <__do_global_dtors_aux_fini_array_entry>:
 8000ae4:	0401 0800 bcf8 bc08 469e 4770               .........FpG
